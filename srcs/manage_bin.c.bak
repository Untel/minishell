/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   manage_bin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riblanc <riblanc@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/04 01:56:11 by riblanc           #+#    #+#             */
/*   Updated: 2020/02/04 04:21:38 by riblanc          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <sys/types.h>


int		try_exec(char *path, char **argv, char **envp, pid_t child)
{
	int		status;
	int		ret;

	if (child == -1)
		return -1; //Failed
	if (child > 0)
	{
		/* I am the parent - wait for the child to finish */
		pid_t pid = waitpid(child, &status, 0);
		printf("status: %d\n", status);
		return (status);
	}
	else
	{ /* I am the child */
		// do something interesting
		ret = execve(path, argv, envp); // "ls ."
		return (ret);
	}
	return (-1);
}

int		exec_bin(t_list *lst_env, t_cmd *cmd)
{
	char	**paths;
	char	*tmp[2];
	char	*res;
	int		ret;
	pid_t child = -1;

	paths = ft_split(get_value(lst_env, "PATH"), ':');
	int		i = -1;
	tmp[1] = cmd->argv[0];
	child = fork();
	while (paths[++i])
	{
		tmp[0] = paths[i];
		res = ft_strmjoin(2, tmp, "/");
		if (!(ret = try_exec(res, cmd->argv, convert_env_list(lst_env), child)))
			break ;
	}
	if (child == 0 && ret == -1)
	{
		exit(ret);
		return (ret);
	}
	else if (ret == -1)
		printf("pas trouve\n");
	return (ret != -1);
}
